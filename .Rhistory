Longitude = coords[,1],
stringsAsFactors = FALSE
)
} else if (ext %in% c("csv", "xlsx")) {
if (ext == "csv") {
df <- read_csv(input$file_upload$datapath)
} else {
df <- read_excel(input$file_upload$datapath)
}
df <- normalize_latlon(df)
} else {
showNotification("Unsupported file type", type = "error")
return(NULL)
}
# Store Habitat values if column exists
if ("Habitat" %in% names(df)) {
shared$habitats <- unique(df$Habitat)
} else {
shared$habitats <- NULL
}
df
})
# Run forecast on each point
forecast_data <- eventReactive(input$run_forecast, {
points <- get_points_from_upload()
req(points)
points |>
rowwise() |>
mutate(
forecast = list(tryCatch(
get_forecast(Latitude, Longitude),
error = function(e) tibble(error = "NWS request failed"))
)
) |>
unnest(forecast)
})
# Output forecast table
output$forecast_table <- renderTable({
forecast_data()
})
# ---- y = x^2 ----
observe({
shared$y <- input$x_input^2
})
output$plot_y <- renderPlot({
x <- input$x_input
y <- x^2
plot(x, y, pch = 16, col = "blue",
main = "y = x²",
xlab = "x", ylab = "y")
})
# ---- z = log(y) ----
output$plot_z <- renderPlot({
req(shared$y)
z <- log(shared$y)
plot(shared$y, z, pch = 16, col = "darkgreen",
main = "z = log(y)",
xlab = "y", ylab = "z")
})
output$y_value <- renderText({
req(shared$y)
paste("Current value of y:", round(shared$y, 2))
})
output$xy_table <- renderTable({
req(shared$y)
data.frame(
x = input$x_input,
y = shared$y
)
})
# ---- Habitat Ranges UI ----
output$habitat_ranges <- renderUI({
req(shared$habitats)
tagList(
h4("Set min and max for each habitat:"),
lapply(shared$habitats, function(hab) {
tagList(
strong(hab),
numericInput(paste0("min_", hab), "Min:", value = NA),
numericInput(paste0("max_", hab), "Max:", value = NA),
tags$hr()
)
})
)
})
}
shinyApp(ui, server)
# ---- Function to get 3-day weather ----
# Inspired by https://3mw.albert-rapp.de/p/weather-api
get_forecast <- function(lat, lon) {
# Get point metadata including grid data URL
point_meta <- request("https://api.weather.gov") |>
req_url_path_append("points", paste0(lat, ",", lon)) |>
req_perform() |>
resp_body_json()
grid_url <- point_meta$properties$forecastGridData
grid_data <- request(grid_url) |>
req_perform() |>
resp_body_json() |>
pluck("properties")
extract_quant_values <- function(var, label) {
tibble(
start_time = map_chr(var$values, "validTime"),
value = map_dbl(var$values, "value"),
variable = label
) |>
separate(start_time, into = c("start", "duration"), sep = "/") |>
mutate(
start = ymd_hms(start),
date = as_date(start)
)
}
# Extract variables of interest
temp_max <- extract_quant_values(grid_data$maxTemperature, "max_temp")
temp_min <- extract_quant_values(grid_data$minTemperature, "min_temp")
wind_speed <- extract_quant_values(grid_data$windSpeed, "wind_speed")
rh_min <- extract_quant_values(grid_data$minRelativeHumidity, "min_rh")
precip_amt <- extract_quant_values(grid_data$quantitativePrecipitation, "precip_amt")
# Combine and summarize to daily average values for next 3 days
forecast_all <- bind_rows(temp_max, temp_min, wind_speed, rh_min, precip_amt) |>
filter(date <= Sys.Date() + 3) |>
group_by(date, variable) |>
summarize(value = mean(value, na.rm = TRUE), .groups = "drop") |>
pivot_wider(names_from = variable, values_from = value)
forecast_all
}
# ---- UI ----
ui <- fluidPage(
titlePanel("RxFire Engine Prototype"),
tabsetPanel(
tabPanel("Weather Forecast",
sidebarLayout(
sidebarPanel(
fileInput("file_upload", "Upload shapefile (.zip) or spreadsheet (.csv/.xlsx)"),
actionButton("run_forecast", "Run Forecast")
),
mainPanel(
tableOutput("forecast_table")
)
)
),
tabPanel("Habitat Rotation Intervals",
sidebarLayout(
sidebarPanel(
uiOutput("habitat_ranges")
),
mainPanel(
plotOutput("plot_y")
)
)
),
tabPanel("Burn Optimization",
mainPanel(
)
)
)
)
# ---- Server ----
server <- function(input, output, session) {
shared <- reactiveValues(y = NULL, habitats = NULL)
# Helper to normalize lat/lon column names
normalize_latlon <- function(df) {
lat_names <- c("Latitude", "Lat", "latitude", "lat")
lon_names <- c("Longitude", "Long", "longitude", "long")
lat_col <- intersect(names(df), lat_names)
lon_col <- intersect(names(df), lon_names)
validate(
need(length(lat_col) > 0 && length(lon_col) > 0,
"Spreadsheet must include recognizable latitude and longitude columns.")
)
df <- df |>
rename(Latitude = all_of(lat_col[1]),
Longitude = all_of(lon_col[1]))
df
}
# Read uploaded file and extract lat/lon
get_points_from_upload <- reactive({
req(input$file_upload)
ext <- tools::file_ext(input$file_upload$name)
temp_dir <- tempdir()
if (ext == "zip") {
unzip(input$file_upload$datapath, exdir = temp_dir)
shp_file <- list.files(temp_dir, pattern = "\\.shp$", full.names = TRUE)
shp_data <- st_read(shp_file[1])
centroids <- st_centroid(shp_data)
coords <- st_coordinates(centroids)
df <- data.frame(
Unit = shp_data$Name %||% paste0("Unit_", seq_len(nrow(shp_data))),
Latitude = coords[,2],
Longitude = coords[,1],
stringsAsFactors = FALSE
)
} else if (ext %in% c("csv", "xlsx")) {
if (ext == "csv") {
df <- read_csv(input$file_upload$datapath)
} else {
df <- read_excel(input$file_upload$datapath)
}
df <- normalize_latlon(df)
} else {
showNotification("Unsupported file type", type = "error")
return(NULL)
}
# Store Habitat values if column exists
if ("Habitat" %in% names(df)) {
shared$habitats <- unique(df$Habitat)
} else {
shared$habitats <- NULL
}
df
})
# Run forecast on each point
forecast_data <- eventReactive(input$run_forecast, {
points <- get_points_from_upload()
req(points)
points |>
rowwise() |>
mutate(
forecast = list(tryCatch(
get_forecast(Latitude, Longitude),
error = function(e) tibble(error = "NWS request failed"))
)
) |>
unnest(forecast)
})
# Output max temp in 3-day interval for each unit
output$forecast_bullets <- renderUI({
df <- forecast_data()
req(df)
df_max <- df |>
group_by(Unit) |>
filter(max_temp == max(max_temp, na.rm = TRUE)) |>
slice_head(n = 1) |>  # In case of ties, take the first
ungroup()
bullets <- df_max |>
mutate(msg = paste0(
"<li><strong>", Unit, "</strong> will experience a maximum temperature of <strong>",
round(max_temp, 1), "°F</strong> on <strong>", date, "</strong> in the next three days.</li>"
)) |>
pull(msg) |>
paste(collapse = "\n")
HTML(paste0("<ul>", bullets, "</ul>"))
})
# ---- Habitat Ranges UI ----
output$habitat_ranges <- renderUI({
req(shared$habitats)
tagList(
h4("Set min and max for each habitat:"),
lapply(shared$habitats, function(hab) {
tagList(
strong(hab),
numericInput(paste0("min_", hab), "Min:", value = NA),
numericInput(paste0("max_", hab), "Max:", value = NA),
tags$hr()
)
})
)
})
}
shinyApp(ui, server)
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
?leafletOutput()
library(leaflet)
install.packages("leaflet")
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
# ---- Function to get 3-day weather ----
# Inspired by https://3mw.albert-rapp.de/p/weather-api
get_forecast <- function(lat, lon) {
# Get point metadata including grid data URL
point_meta <- request("https://api.weather.gov") |>
req_url_path_append("points", paste0(lat, ",", lon)) |>
req_perform() |>
resp_body_json()
grid_url <- point_meta$properties$forecastGridData
grid_data <- request(grid_url) |>
req_perform() |>
resp_body_json() |>
pluck("properties")
extract_quant_values <- function(var, label) {
tibble(
start_time = map_chr(var$values, "validTime"),
value = map_dbl(var$values, "value"),
variable = label
) |>
separate(start_time, into = c("start", "duration"), sep = "/") |>
mutate(
start = ymd_hms(start),
date = as_date(start)
)
}
# Extract variables of interest
temp_max <- extract_quant_values(grid_data$maxTemperature, "max_temp")
temp_min <- extract_quant_values(grid_data$minTemperature, "min_temp")
wind_speed <- extract_quant_values(grid_data$windSpeed, "wind_speed")
rh_min <- extract_quant_values(grid_data$minRelativeHumidity, "min_rh")
precip_amt <- extract_quant_values(grid_data$quantitativePrecipitation, "precip_amt")
# Combine and summarize to daily average values for next 3 days
forecast_all <- bind_rows(temp_max, temp_min, wind_speed, rh_min, precip_amt) |>
mutate(
value = ifelse(variable %in% c("max_temp", "min_temp"), value * 9/5 + 32, value)
) |>
filter(date <= Sys.Date() + 3) |>
group_by(date, variable) |>
summarize(value = mean(value, na.rm = TRUE), .groups = "drop") |>
pivot_wider(names_from = variable, values_from = value)
forecast_all
}
# ---- UI ----
ui <- fluidPage(
titlePanel("RxFire Engine Prototype"),
tabsetPanel(
tabPanel("Weather Forecast",
sidebarLayout(
sidebarPanel(
fileInput("file_upload", "Upload shapefile (.zip) or spreadsheet (.csv/.xlsx)"),
actionButton("run_forecast", "Run Forecast")
),
mainPanel(
uiOutput("forecast_bullets"),
leafletOutput("unit_map", height = 400)
)
)
),
tabPanel("Habitat Rotation Intervals",
sidebarLayout(
sidebarPanel(
fileInput("file", "Upload CSV", accept = ".csv"),
uiOutput("threshold_inputs"),
actionButton("evaluate", "Evaluate Burn Status")
),
mainPanel(
h3("Evaluation Results"),
uiOutput("feedback_output")
)
)
),
tabPanel("Burn Optimization",
mainPanel(
)
)
)
)
# ---- Server ----
server <- function(input, output, session) {
shared <- reactiveValues(y = NULL, habitats = NULL)
# Helper to normalize lat/lon column names
normalize_latlon <- function(df) {
lat_names <- c("Latitude", "Lat", "latitude", "lat")
lon_names <- c("Longitude", "Long", "longitude", "long")
lat_col <- intersect(names(df), lat_names)
lon_col <- intersect(names(df), lon_names)
validate(
need(length(lat_col) > 0 && length(lon_col) > 0,
"Spreadsheet must include recognizable latitude and longitude columns.")
)
df <- df |>
rename(Latitude = all_of(lat_col[1]),
Longitude = all_of(lon_col[1]))
df
}
# Read uploaded file and extract lat/lon
get_points_from_upload <- reactive({
req(input$file_upload)
ext <- tools::file_ext(input$file_upload$name)
temp_dir <- tempdir()
if (ext == "zip") {
unzip(input$file_upload$datapath, exdir = temp_dir)
shp_file <- list.files(temp_dir, pattern = "\\.shp$", full.names = TRUE)
shp_data <- st_read(shp_file[1])
centroids <- st_centroid(shp_data)
coords <- st_coordinates(centroids)
df <- data.frame(
Unit = shp_data$Name %||% paste0("Unit_", seq_len(nrow(shp_data))),
Latitude = coords[,2],
Longitude = coords[,1],
stringsAsFactors = FALSE
)
} else if (ext %in% c("csv", "xlsx")) {
if (ext == "csv") {
df <- read_csv(input$file_upload$datapath)
} else {
df <- read_excel(input$file_upload$datapath)
}
df <- normalize_latlon(df)
} else {
showNotification("Unsupported file type", type = "error")
return(NULL)
}
# Run forecast on each point
forecast_data <- eventReactive(input$run_forecast, {
points <- get_points_from_upload()
req(points)
points |>
rowwise() |>
mutate(
forecast = list(tryCatch(
get_forecast(Latitude, Longitude),
error = function(e) tibble(error = "NWS request failed"))
)
) |>
unnest(forecast)
})
# Map units
output$unit_map <- renderLeaflet({
df <- forecast_data()
req(df)
leaflet(df) |>
addTiles() |>
addCircleMarkers(
lng = ~Longitude, lat = ~Latitude,
label = ~Unit, radius = 5,
fillOpacity = 0.8, color = "blue"
)
})
# Output max temp in 3-day interval for each unit
output$forecast_bullets <- renderUI({
df <- forecast_data()
req(df)
df_max <- df |>
group_by(Unit) |>
filter(max_temp == max(max_temp, na.rm = TRUE)) |>
slice_head(n = 1) |>  # In case of ties, take the first
ungroup()
bullets <- df_max |>
mutate(msg = paste0(
"<li><strong>", Unit, "</strong> will experience a maximum temperature of <strong>",
round(max_temp, 1), "°F</strong> on <strong>", date, "</strong> in the next three days.</li>"
)) |>
pull(msg) |>
paste(collapse = "\n")
HTML(paste0("<ul>", bullets, "</ul>"))
})
})
# Reactive: Get unique habitats
unique_habitats <- reactive({
req(df())
unique(df()$Habitat)
})
# Dynamic UI: min/max inputs for each Habitat
output$threshold_inputs <- renderUI({
req(unique_habitats())
lapply(unique_habitats(), function(hab) {
tagList(
h4(hab),
numericInput(paste0("min_", hab), "Min Years Since Burn", value = 1),
numericInput(paste0("max_", hab), "Max Years Since Burn", value = 10)
)
})
})
# Reactive: Generate feedback after evaluation
output$feedback_output <- renderUI({
req(input$evaluate)
isolate({
df <- df()
habitats <- unique_habitats()
# Collect user-defined min/max thresholds
thresholds <- lapply(habitats, function(hab) {
min_val <- input[[paste0("min_", hab)]]
max_val <- input[[paste0("max_", hab)]]
data.frame(Habitat = hab, Min = min_val, Max = max_val)
}) %>% bind_rows()
# Join thresholds to user data
df <- df %>%
left_join(thresholds, by = "Habitat")
# Generate feedback messages
messages <- df %>%
rowwise() %>%
mutate(Message = case_when(
YearsSinceBurn < Min ~ paste(Unit, "was burned recently."),
YearsSinceBurn > Max ~ paste(Unit, "has not been burned recently enough."),
TRUE ~ paste(Unit, "falls within the ideal rotation interval.")
)) %>%
pull(Message)
# Output as bullet list
HTML(paste("<ul>", paste(paste0("<li>", messages, "</li>"), collapse = ""), "</ul>"))
})
})
}
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
runApp('GitHub/RxFireEngine')
rsconnect::deployApp()
setwd("~/GitHub/RxFireEngine")
rsconnect::deployApp()
runApp()
rsconnect::deployApp()
